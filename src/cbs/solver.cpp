
#include "mess2_algorithm_plugins/cbs/solver.hpp"

// "i" domain (corresponds to the order that actors are added to instance) : instance->actors, search engines
// "j" domain (corresponds to the order indices_actors generated in root) : 

namespace mess2_algorithms
{
    CBS::CBS(std::shared_ptr<Instance> &_instance, bool _sipp, int _screen) : screen(_screen), focal_w(1.0), instance(_instance)
    // mdd_helper(initial_constraints, search_engines),
    // rectangle_helper(instance),
    // mutex_helper(instance, initial_constraints),
    // corridor_helper(search_engines, initial_constraints),
    // heuristic_helper(instance.getDefaultNumberOfAgents(), paths, search_engines, initial_constraints, mdd_helper)
    {
        clock_t t = std::clock();
        initial_constraints.resize(instance->n_actors, ConstraintTable(instance));
        search_engines.resize(instance->n_actors);
        for (int iter = 0; iter < instance->n_actors; ++iter) {
            if (_sipp) {
                std::cerr << "CBS::CBS : sipp not implemented" << std::endl;
            } else {
                search_engines[iter] = std::make_shared<SpaceTimeAStar>(instance, iter);
            }
            runtime_preprocessing = (double) (std::clock() - t) / CLOCKS_PER_SEC;
            instance->indices_actors.resize(instance->n_actors);

            // mutex_helper.search_engines = search_engines;

            // screen for debugging omitted
        }
    };


    bool CBS::generate_root()
    {
        dummy_start = std::make_shared<CBSNode>();
        dummy_start->g_cummulative = 0.0;
        paths.resize(instance->n_actors);

        // mdd_helper.init(num_of_agents);
    	// heuristic_helper.init();

        if (paths_found_initially.empty())
        {
            paths_found_initially.resize(instance->n_actors);

            for (auto i = 0; i < instance->n_actors; ++i) {
                instance->indices_actors[i] = i;
            }

            if (random_root) {
                std::random_device rd;
                std::mt19937 g(rd());
                std::shuffle(std::begin(instance->indices_actors), std::end(instance->indices_actors), g);
            }

            for (auto i = 0; i < instance->n_actors; ++i) {
                auto j = instance->indices_actors[i]; // everything mapped from i to j except search engines and instance->actors in indices_actors
                std::cout << "generating root" << j << std::endl;
                assert(search_engines[j]->actor->name == instance->actors[j]->name);
                paths_found_initially[j] = search_engines[j]->find_path(dummy_start, initial_constraints[j], paths, 0.0, use_cat);
                if (paths_found_initially[j].empty()) {
                    std::cerr << "CBS::generate_root : no path exists for " << instance->actors[j]->name << std::endl;
                    return false;
                }
                
                paths[j] = paths_found_initially[j];
                dummy_start->g_cummulative += (double) paths_found_initially[j][paths_found_initially[j].size() - 1].score;
                n_ll_expanded += search_engines[j]->n_expanded;
                n_ll_generated += search_engines[j]->n_generated;
            }
        } else {
            for (auto i = 0; i < instance->n_actors; ++i) {
                paths[i] = paths_found_initially[i];
                dummy_start->g_cummulative += (double) paths_found_initially[i][paths_found_initially[i].size() - 1].cost;
            }
        }

        dummy_start->h_cummulative = 0.0;
        dummy_start->handle_open = list_open.push(dummy_start);
        dummy_start->handle_focal = list_focal.push(dummy_start);

        n_hl_generated += 1;
        dummy_start->time_generated = n_hl_generated;
        table_of_all_nodes.push_back(dummy_start);
        (void) find_conflicts(dummy_start);
        score_min = std::max(score_min, (double) dummy_start->g_cummulative);
        threshold_list_focal = score_min * focal_w;

        return true;
    }


    bool CBS::generate_child(std::shared_ptr<CBSNode> &_node, const std::shared_ptr<CBSNode> &_parent)
    {
        assert(_node->constraints.size() > 0);
        clock_t time_init = std::clock();

        _node->parent = _parent;
        _node->g_cummulative = _parent->g_cummulative;
        _node->depth = _parent->depth + 1;

        int i1, i2;
        double t1, t2, tX;
        constraint_type type;
        std::tie(i1, i2, t1, t2, tX, type) = _node->constraints.front();
        std::shared_ptr<Key3D> key1, key2;

        if (type == constraint_type::LEQLENGTH) {
            std::cout << "path0" << std::endl;
            // if ((int)node->constraints.size() == 2) // generated by corridor-target conflict
            // {
            //     int a = get<0>(node->constraints.back()); // it is a G-length constraint or a range constraint on this agent
            //     int lowerbound = (int)paths[a]->size() - 1;
            //     if (!findPathForSingleAgent(node, a, lowerbound))
            //     {
            //         runtime_generate_child += (double)(clock() - t1) / CLOCKS_PER_SEC;
            //         return false;
            //     }
            // }
            // for (auto index_actor = 0; index_actor < instance->n_actors; ++index_actor) {
            //     if (i1 == index_actor) {
            //         continue;
            //     }
            //     auto path_curr = paths[index_actor];
            //     for (auto i = 0; i < static_cast<int>(path_curr.size()); ++i) {
            //         if (path_curr[i].time < t1) {
            //             continue;
            //         }
            //         key2 = instance->graph->lookup_vertex(path_curr[i].index_vertex)->point->key;
            //         bool is_conflicting = find_collisions(key1, key2, instance->actors[index_actor]->radius + instance->actors[i1]->radius);
            //         if (is_conflicting) {
            //             auto lowerbound = paths[index_actor].back().time;
            //             if (!find_path_for_single_actor(_node, index_actor, lowerbound)) {
            //                 runtime_generate_children += (double) (std::clock() - time_init) / CLOCKS_PER_SEC;
            //                 return false;
            //             }
            //             break;
            //         }
            //     }
            // }
        } else if (type == constraint_type::POSITIVE_POINT) {
            std::cout << "path1" << std::endl;
            // assert(_node->constraints.size() == 1);
            // for (const auto &constraint : _node->constraints) {
            //     std::tie(i1, i2, t1, t2, tX, type) = constraint;
            //     key1 = instance->graph->lookup_vertex(i2)->point->key;
            //     for (auto index_actor = 0; index_actor < instance->n_actors; ++index_actor) {
            //         if (i1 == index_actor) {
            //             continue;
            //         }
            //         std::cout << index_actor << std::endl;
            //         auto path_curr = paths[i1];
            //         for (const auto &elem_curr : path_curr) {
            //             key2 = instance->graph->lookup_vertex(elem_curr.index_vertex)->point->key;
            //             auto p1 = instance->graph->lookup_point(key1->index_key);
            //             auto p2 = instance->graph->lookup_point(key2->index_key);
            //             auto distance = std::sqrt(
            //                 std::pow(*(p2->x)- *(p1->x), 2) +
            //                 std::pow(*(p2->y)- *(p1->y), 2) +
            //                 std::pow(*(p2->z)- *(p1->z), 2)
            //             );
            //             std::cout << key1->index_key << ", " << key2->index_key << ", " << distance << std::endl;
            //             // if (true) {
            //             //     key2 = instance->graph->lookup_vertex(elem_curr.index_vertex)->point->key;
            //             //     bool is_conflicting = find_collisions(key1, key2, tX);
            //             //     std::cout << "bool : " << is_conflicting << std::endl;
            //             //     if (is_conflicting) {
            //             //         auto lowerbound = path_curr.back().time;
            //             //         if (!find_path_for_single_actor(_node, index_actor, lowerbound)) {
            //             //             runtime_generate_children += (double) (std::clock() - time_init) / CLOCKS_PER_SEC;
            //             //             return false;
            //             //         }
            //             //         std::cout << "TRUE" << std::endl;
            //             //     }
            //             // }
            //         }
            //     }
            // }
        } else if (type == constraint_type::POSITIVE_VERTEX) {
            std::cout << "path2" << std::endl;
        } else if (type == constraint_type::POSITIVE_EDGE) {
            std::cout << "path3" << std::endl;
        } else {
            std::cout << "path4" << std::endl;
            assert(_node->constraints.size() == 1);

            auto lowerbound = paths[i1].back().time;
            if (!find_path_for_single_actor(_node, i1, lowerbound)) {
                runtime_generate_children += (double) (std::clock() - time_init) / CLOCKS_PER_SEC;
                return false;
            }
        }

        assert(!_node->paths.empty());
        (void) find_conflicts(_node);
        // heuristic_helper.compute_quick_heuristics
        runtime_generate_children += (double) (std::clock() - time_init) / CLOCKS_PER_SEC;
        return true;
    }


    void CBS::copy_conflicts(const std::list<std::shared_ptr<Conflict>> &_conflicts, std::list<std::shared_ptr<Conflict>> &_copy, const std::list<int> &_actors_excluded)
    {
        for (const auto &conflict : _conflicts) {
            bool found = false;
            for (auto a : _actors_excluded) {
                if (conflict->index_actor1 == a || conflict->index_actor2 == a) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                assert(!conflict->constraint1.empty());
                assert(!conflict->constraint2.empty());
                _copy.push_back(conflict);
            }
        }
    }


    bool CBS::find_collisions(const std::shared_ptr<Key3D> &_key1, const std::shared_ptr<Key3D> &_key2, const double &_radius)
    {
        auto p1 = instance->graph->lookup_point(_key1->index_key);
        auto p2 = instance->graph->lookup_point(_key2->index_key);
        auto dx = std::abs(*(p1->x) - *(p2->x));
        auto dy = std::abs(*(p1->y) - *(p2->y));
        auto dz = std::abs(*(p1->z) - *(p2->z));
        auto distance = std::sqrt(dx * dx + dy * dy + dz * dz);
        if (distance <= _radius) {
            return true;
        }
        return false;
    }


    void CBS::find_conflicts(std::shared_ptr<CBSNode>& _node, int &_index_actor1, int &_index_actor2)
    {
        // assume that both actor indices are in the j domain when called from other find_conflicts method
        auto actor1 = instance->actors[_index_actor1];
        auto actor2 = instance->actors[_index_actor2];
        auto path1 = paths[_index_actor1];
        auto path2 = paths[_index_actor2];
        auto counter = std::pair<int, int>(0, 0);
        auto sizes = std::pair<int, int>(static_cast<int>(path1.size()) - 1, static_cast<int>(path2.size()) - 1);

        auto key1 = instance->graph->lookup_key_by_index_vertex(path1[counter.first].index_vertex);
        auto key2 = instance->graph->lookup_key_by_index_vertex(path2[counter.second].index_vertex);
        
        double t1 = 0.0;
        double t2 = 0.0;
        double t3 = 0.0;
        double t4 = 0.0;
        std::shared_ptr<Vertex> vertex1;
        std::shared_ptr<Vertex> vertex2;
        bool is_done1 = false;
        bool is_done2 = false;
        bool is_updated1 = false;
        bool is_updated2 = false;

        while (counter != sizes) {
            t1 = path1[counter.first].time;
            t2 = path2[counter.second].time;
            if (t1 <= t2 && !is_done1) {
                vertex1 = instance->graph->lookup_vertex(path1[counter.first].index_vertex);
                key1 = vertex1->point->key;
                is_updated1 = true;
                is_updated2 = false;
            } else if (t2 < t1 && !is_done2) {
                vertex2 = instance->graph->lookup_vertex(path2[counter.second].index_vertex);
                key2 = vertex2->point->key;
                is_updated1 = false;
                is_updated2 = true;
            } else if (t1 <= t2 && is_done1 && !is_done2) {
                vertex2 = instance->graph->lookup_vertex(path2[counter.second].index_vertex);
                key2 = vertex2->point->key;
                is_updated1 = false;
                is_updated2 = true;
            } else if (t2 < t1 && !is_done1 && is_done2) {
                vertex1 = instance->graph->lookup_vertex(path1[counter.first].index_vertex);
                key1 = vertex1->point->key;
                is_updated1 = true;
                is_updated2 = false;
            }

            if (!is_done1 && counter.first == sizes.first) {
                is_done1 = true;
            }
            if (!is_done2 && counter.second == sizes.second) {
                is_done2 = true;
            }

            // determine if any collisions occur
            bool is_conflicting = find_collisions(key1, key2, actor1->radius + actor2->radius);

            // if collisions occur ...
            if (is_conflicting) {
                auto conflict = std::make_shared<Conflict>();
                // first actor reached target
                if (target_reasoning && counter.first == sizes.first) {
                    conflict->define_as_target(_index_actor1, _index_actor2, vertex1->index_vertex, path1[counter.first - 1].time, path1[counter.first].time, path1[counter.first].time);

                // second actor reached target 
                } else if (target_reasoning && counter.second == sizes.second) {
                    conflict->define_as_target(_index_actor2, _index_actor1, vertex2->index_vertex, path2[counter.second - 1].time, path2[counter.second].time, path2[counter.second].time);

                // neither actor at target, define as point (multi point additions in ct build so only provide single index here (key indices = point indices given graph generation nature))
                } else {
                    auto i11 = std::max(int(0), counter.first - 1);
                    auto i12 = std::min(counter.first + 1, sizes.first);
                    auto i21 = std::max(int(0), counter.second - 1);
                    auto i22 = std::min(counter.second + 1, sizes.second);

                    auto t11 = path1[i11].time;
                    auto t12 = path1[i12].time;
                    auto t21 = path2[i21].time;
                    auto t22 = path2[i22].time;

                    std::cout << "define point conflict : " << t11 << ", " << t12 << ", " << t21 << ", " << t22 << std::endl;
                    conflict->define_as_point(_index_actor1, _index_actor2, key1->index_key, key2->index_key, t11, t12, t21, t22, actor1->radius + actor2->radius);
                }
                assert(!conflict->constraint1.empty());
                assert(!conflict->constraint2.empty());
                _node->conflicts_unknown.push_back(conflict);

            // edge conflict (likely won't occur in high density graph, but in graph where actor collisions can transition along the same edge without occupying conflicting points, edge conflicts may exist)
            } else if (counter.first - 1 < sizes.first - 1 && counter.second - 1 < sizes.second && key1->index_key == path2[counter.second - 1].index_vertex && key2->index_key == path1[counter.first - 1].index_vertex) {
                auto conflict = std::make_shared<Conflict>();
                auto edge1 = instance->graph->find_edge_by_vertex_indices(key1->index_key, key2->index_key); // edge actor 1 takes
                auto edge2 = instance->graph->find_edge_by_vertex_indices(key2->index_key, key1->index_key); // edge actor 2 takes
                t3 = 0.0;
                t4 = 0.0;

                auto i11 = std::max(int(0), counter.first - 2);
                auto i12 = std::min(counter.first, sizes.first);
                auto i21 = std::max(int(0), counter.second - 2);
                auto i22 = std::min(counter.second, sizes.second);

                auto t11 = path1[i11].time;
                auto t12 = path1[i12].time;
                auto t21 = path2[i21].time;
                auto t22 = path2[i22].time;
                
                auto edges11 = instance->graph->lookup_edges(edge1->vertex_parent->index_vertex);
                auto edges12 = instance->graph->lookup_edges(edge1->vertex_child->index_vertex);
                auto edges21 = instance->graph->lookup_edges(edge2->vertex_parent->index_vertex);
                auto edges22 = instance->graph->lookup_edges(edge2->vertex_child->index_vertex);
                for (const auto &edge11 : edges11) {
                    if (actor1->lookup_t(edge11->index_edge) > t3) {
                        t3 = actor1->lookup_t(edge11->index_edge);
                    }
                }
                for (const auto &edge12 : edges12) {
                    if (actor1->lookup_t(edge12->index_edge) > t3) {
                        t3 = actor1->lookup_t(edge12->index_edge);
                    }
                }
                for (const auto &edge21 : edges21) {
                    if (actor2->lookup_t(edge21->index_edge) > t4) {
                        t4 = actor2->lookup_t(edge21->index_edge);
                    }
                }
                for (const auto &edge22 : edges22) {
                    if (actor2->lookup_t(edge22->index_edge) > t4) {
                        t4 = actor2->lookup_t(edge22->index_edge);
                    }
                }
                
                conflict->define_as_edge(_index_actor1, _index_actor2, edge1->index_edge, t11, t12, t21, t22, t3, t4);
                assert(!conflict->constraint1.empty());
                assert(!conflict->constraint2.empty());
                _node->conflicts_unknown.push_back(conflict);
            }

            if (counter.first < sizes.first && is_updated1) {
                counter.first += 1;
            }
            if (counter.second < sizes.second && is_updated2) {
                counter.second += 1;
            }
        } 
    }


    void CBS::find_conflicts(std::shared_ptr<CBSNode>& _node)
    {
        if (_node->parent != nullptr) {
            std::list<int> indices_updated;
            for (const auto &path : _node->paths) {
                indices_updated.push_back(path.first); // assume that indices added to the path pair are already in the "j" domain
            }
            (void) copy_conflicts(_node->parent->conflicts_known, _node->conflicts_known, indices_updated);
            (void) copy_conflicts(_node->parent->conflicts_unknown, _node->conflicts_unknown, indices_updated);
            for (auto i = indices_updated.begin(); i != indices_updated.end(); ++i) {
                for (auto j = 0; j < instance->n_actors; ++j) {
                    if (*i == j) {
                        continue;
                    }
                    bool skip = false;
                    for (auto k = indices_updated.begin(); k != i; ++k) {
                        if (*k == j) {
                            skip = true;
                            break;
                        }
                    }
                    if (!skip) {
                        (void) find_conflicts(_node, *i, j);
                    }
                }
            }
        } else {
            for (auto i = 0; i < instance->n_actors; ++i) {
                for (auto j = i + 1; j < instance->n_actors; ++j) {
                    auto k = instance->indices_actors[i];
                    auto l = instance->indices_actors[j];
                    (void) find_conflicts(_node, k, l);
                }
            }
        }
    }


    bool CBS::find_path_for_single_actor(std::shared_ptr<CBSNode> &_node, int _index_actor, double _lowerbound)
    {
        clock_t time_init = std::clock();
        auto path_new = search_engines[_index_actor]->find_path(_node, initial_constraints[_index_actor], paths, _lowerbound, use_cat);
        n_ll_expanded += search_engines[_index_actor]->n_expanded;
        n_ll_generated += search_engines[_index_actor]->n_generated;
        runtime_build_ct += search_engines[_index_actor]->runtime_build_ct;
        runtime_build_cat += search_engines[_index_actor]->runtime_build_cat;
        runtime_path_finding += (double) (std::clock() - time_init) / CLOCKS_PER_SEC;
        if (!path_new.empty()) {
            assert(!are_paths_equal(paths[_index_actor], path_new));
            _node->paths.emplace_back(_index_actor, path_new);
            _node->g_cummulative = _node->g_cummulative - paths[_index_actor].back().cost + path_new.back().cost;
            paths[_index_actor] = _node->paths.back().second;
            return true;
        } else {
            return false;
        }
    }


    void CBS::update_list_focal()
    {
        auto head_open = list_open.top();
        if (head_open->g_cummulative + head_open->h_cummulative > score_min)
        {
            score_min = head_open->g_cummulative + head_open->h_cummulative;
            double threshold_list_focal_new = score_min * focal_w;
            for (auto n : list_open)
            {
                if (n->g_cummulative + n->h_cummulative > threshold_list_focal && n->g_cummulative + n->h_cummulative <= threshold_list_focal_new) {
                    n->handle_focal = list_focal.push(n);
                }
                threshold_list_focal = threshold_list_focal_new;
            }
        }
    }


    bool CBS::solve(double _time_limit, double _cost_lowerbound, double _cost_upperbound)
    {
        this->score_min = _cost_lowerbound;
        this->cost_upperbound = _cost_upperbound;
        this->time_limit = _time_limit;

        // screen for debugging omitted

        time_start = std::clock();

        bool is_root = generate_root();
        std::cout << "done generate root" << std::endl;
        bool first_iter = true;

        while (!list_open.empty() && !solution_found) {
        // for (auto wter = 0; wter < 0; ++wter) {

            (void) update_list_focal();
            if (score_min >= cost_upperbound) {
                solution_cost = score_min;
                solution_found = false;
                break;
            }

            runtime = (double) (std::clock() - time_start) / CLOCKS_PER_SEC;
            if (runtime > time_limit || n_hl_expanded > node_limit) {
                solution_cost = -1;
                solution_found = false;
                break;
            }

            auto curr = list_focal.top();
            list_focal.pop();
            list_open.erase(curr->handle_open);
            update_paths(curr);

            if (curr->conflicts_unknown.size() + curr->conflicts_known.size() == 0 && first_iter != true) {
                solution_found = true;
                solution_cost = curr->g_cummulative;
                goal_node = curr;
                break;
            }
            first_iter = false;

            // some heuristic logic that i am temporarilly omitting

            n_hl_expanded += 1;
            curr->time_expanded = n_hl_expanded;
            bool found_bypass = true;
            while (found_bypass) {
                if (curr->conflicts_unknown.size() + curr->conflicts_known.size() == 0) {
                    solution_found = true;
                    solution_cost = curr->g_cummulative;
                    goal_node = curr;
                    break;
                }
                found_bypass = false;

                std::shared_ptr<CBSNode> children[2] = { std::make_shared<CBSNode>(), std::make_shared<CBSNode>() };

                curr->conflict_chosen = choose_conflict(curr);

                if (disjoint_splitting && curr->conflict_chosen->type == conflict_type::STANDARD) {
                    int first = (bool) (std::rand() % 2);

                    if (first) {

                        children[0]->constraints = curr->conflict_chosen->constraint1;
                        int i1, i2;
                        double t1, t2, tX;
                        constraint_type type;
                        std::tie(i1, i2, t1, t2, tX, type) = curr->conflict_chosen->constraint1.back();

                        if (type == constraint_type::POINT) {
                            children[1]->constraints.emplace_back(i1, i2, t1, t2, tX, constraint_type::POSITIVE_POINT);
                        } else if (type == constraint_type::VERTEX) {
                            children[1]->constraints.emplace_back(i1, i2, t1, t2, tX, constraint_type::POSITIVE_VERTEX);
                        } else if (type == constraint_type::EDGE) {
                            children[1]->constraints.emplace_back(i1, i2, t1, t2, tX, constraint_type::POSITIVE_EDGE);
                        }
                    } else if (!first) {

                        children[1]->constraints = curr->conflict_chosen->constraint2;
                        int i1, i2;
                        double t1, t2, tX;
                        constraint_type type;
                        std::tie(i1, i2, t1, t2, tX, type) = curr->conflict_chosen->constraint1.back();

                        if (type == constraint_type::POINT) {
                            children[0]->constraints.emplace_back(i1, i2, t1, t2, tX, constraint_type::POSITIVE_POINT);
                        } else if (type == constraint_type::VERTEX) {
                            children[0]->constraints.emplace_back(i1, i2, t1, t2, tX, constraint_type::POSITIVE_VERTEX);
                        } else if (type == constraint_type::EDGE) {
                            children[0]->constraints.emplace_back(i1, i2, t1, t2, tX, constraint_type::POSITIVE_EDGE);
                        }
                    }
                } else {
                    children[0]->constraints = curr->conflict_chosen->constraint1;
                    children[1]->constraints = curr->conflict_chosen->constraint2;

                    // TODO : add corridor and rectangle logic
                    // if (curr->conflict->type == conflict_type::RECTANGLE && rectangle_helper.strategy == rectangle_strategy::DR)
                    // {
                    //     int i = (bool)(rand() % 2);
                    //     for (const auto constraint : child[1 - i]->constraints)
                    //     {
                    //         child[i]->constraints.emplace_back(get<0>(constraint), get<1>(constraint), get<2>(constraint), get<3>(constraint), 
                    //                                                                             constraint_type::POSITIVE_BARRIER);
                    //     }
                    // }
                    // else if (curr->conflict->type == conflict_type::CORRIDOR && corridor_helper.getStrategy() == corridor_strategy::DC)
                    // {
                    //     int i = (bool)(rand() % 2);
                    //     assert(child[1 - i]->constraints.size() == 1);
                    //     auto constraint = child[1 - i]->constraints.front();
                    //     child[i]->constraints.emplace_back(get<0>(constraint), get<1>(constraint), get<2>(constraint), get<3>(constraint),
                    //         constraint_type::POSITIVE_RANGE);
                    // }
                }

                bool solved[2] = { false, false };
                // std::vector<std::vector<PathElement>> copy(paths);
                auto copy = paths;

                for (auto i = 0; i < 2; ++i) {
                    if (i > 0) { paths = copy; }
                    solved[i] = generate_child(children[i], curr);
                    if (solved[i]) {
                        children[i]->handle_open = list_open.push(children[i]);
                        n_hl_generated++;
                        children[i]->time_generated = n_hl_generated;
                        if (children[i]->g_cummulative + children[i]->h_cummulative <=threshold_list_focal) {
                            children[i]->handle_focal = list_focal.push(children[i]);
                        }
                        table_of_all_nodes.push_back(children[i]);
                    }
                }
            }
            

            

            // for (const auto &path : paths) {
            //     std::cout << "g : " << path->back().cost << ", h : " << path->back().heuristic << std::endl;
        }




        solution_found = true;
        return solution_found;
    }


    std::shared_ptr<Conflict> CBS::choose_conflict(const std::shared_ptr<CBSNode> &_node) const
    {
        std::shared_ptr<Conflict> conflict_chosen;
        if (_node->conflicts_known.empty() && _node->conflicts_unknown.empty()) {
            return nullptr;
        } else if (!_node->conflicts_known.empty()) {
            conflict_chosen = _node->conflicts_known.back();
            for (const auto &conflict : _node->conflicts_known) {
                if (*conflict_chosen < *conflict) {
                    conflict_chosen = conflict;
                }
            }
        } else {
            conflict_chosen = _node->conflicts_unknown.back();
            for (const auto &conflict : _node->conflicts_unknown) {
                if (*conflict_chosen < *conflict) {
                    conflict_chosen = conflict;
                }
            }
        }
        return conflict_chosen;
    }


    inline void CBS::update_paths(const std::shared_ptr<CBSNode> &_node)
    {
        for (auto i = 0; i < instance->n_actors; ++i) {
            paths[i] = paths_found_initially[i];
        }
        auto curr = _node;
        std::vector<bool> updated(instance->n_actors, false);
        while (curr != nullptr) {
            for (const auto &path : curr->paths) {
                if (!updated[path.first]) {
                    paths[path.first] = path.second;
                    updated[path.first] = true;
                }
            }
            curr = curr->parent;
        }
    }


    void CBS::save_paths(const std::string &_path_goals, bool _simplify)
    {
        for (auto i = 0; i < instance->n_actors; ++i) {
            auto index_actor = instance->indices_actors[i];
            auto name_actor = instance->actors[index_actor]->name;
            auto path = paths[index_actor];          

            std::vector<std::shared_ptr<Vertex>> vertices;
            std::vector<std::tuple<double, double, double, double>> data;

            auto n_path = static_cast<int>(path.size());
            for (auto j = 0; j < n_path; ++j) {
                vertices.push_back(instance->graph->lookup_vertex(path[j].index_vertex));
            }

            if (!_simplify) {
                std::shared_ptr<Vertex> curr;
                for (auto j = 0; j < n_path; ++j) {
                    curr = vertices[j];
                    data.emplace_back(*(curr->point->x), *(curr->point->y), *(curr->point->z), curr->heading);
                }
            } else {
                std::shared_ptr<Vertex> prev;
                std::shared_ptr<Vertex> curr;
                std::shared_ptr<Vertex> next;
                bool is_same_x, is_same_y, is_same_z, will_be_same_x, will_be_same_y, will_be_same_z, is_wait, is_rotate, is_translate_in_plane, is_translate_out_of_plane, will_be_wait, will_be_rotate, will_be_translate_in_plane, will_be_translate_out_of_plane, is_same_theta, will_be_same_theta;
                
                data.emplace_back(*(vertices[0]->point->x), *(vertices[0]->point->y), *(vertices[0]->point->z), vertices[0]->heading);
                for (auto j = 1; j < n_path - 1; ++j) {
                    prev = vertices[j - 1];
                    curr = vertices[j];
                    next = vertices[j + 1];

                    is_same_x = (prev->point->x == curr->point->x);
                    is_same_y = (prev->point->y == curr->point->y);
                    is_same_z = (prev->point->z == curr->point->z);
                    is_same_theta = (prev->heading == curr->heading);

                    will_be_same_x = (next->point->x == curr->point->x);
                    will_be_same_y = (next->point->y == curr->point->y);
                    will_be_same_z = (next->point->z == curr->point->z);
                    will_be_same_theta = (next->heading == curr->heading);

                    is_wait = (is_same_x && is_same_y && is_same_theta);
                    is_rotate = (is_same_x && is_same_y && !is_same_theta);
                    is_translate_in_plane = (is_same_theta && !is_wait && !is_rotate && is_same_z);
                    is_translate_out_of_plane = (is_same_theta && !is_wait && !is_rotate && is_same_x && is_same_y);

                    will_be_wait = (will_be_same_x && will_be_same_y && will_be_same_theta);
                    will_be_rotate = (will_be_same_x && will_be_same_y && !will_be_same_theta);
                    will_be_translate_in_plane = (will_be_same_theta && !will_be_wait && !will_be_rotate && will_be_same_z);
                    will_be_translate_out_of_plane = (will_be_same_theta && !will_be_wait && !will_be_rotate && will_be_same_x && will_be_same_y);

                    if (is_wait || is_rotate) {
                        data.emplace_back(*(curr->point->x), *(curr->point->y), *(curr->point->z), curr->heading);
                    } 
                    
                    if (is_translate_in_plane && !will_be_translate_in_plane) {
                        data.emplace_back(*(curr->point->x), *(curr->point->y), *(curr->point->z), curr->heading);
                    }

                    if (is_translate_out_of_plane && !will_be_translate_out_of_plane) {
                        data.emplace_back(*(curr->point->x), *(curr->point->y), *(curr->point->z), curr->heading);
                    }
                }
                data.emplace_back(*(vertices.back()->point->x), *(vertices.back()->point->y), *(vertices.back()->point->z), vertices.back()->heading);
            }

            auto path_goal = _path_goals + name_actor + ".csv";
            std::string path_new;
            if (!path_goal.empty() && path_goal[0] == '~') {
                const char* home = getenv("HOME");
                if (home) {
                    path_new = std::string(home) + path_goal.substr(1);
                } else {
                    throw std::runtime_error("could not determine the home directory");
                }
            }

            std::ofstream file(path_new);
            if (!file.is_open()) {
                throw std::runtime_error("could not open file for writing");
            }

            file << "x" << ", " << "y" << ", " << "z" << ", " << "theta" << "\n";
            double x, y, z, theta;
            for (auto line : data) {
                x = std::get<0>(line);
                y = std::get<1>(line);
                z = std::get<2>(line);
                theta = std::get<3>(line);
                file << x << ", " << y << ", " << z << ", " << theta * (M_PI / 180) << "\n";
            }

            file.close();
        }
    }

} // namespace mess2_algorithms
